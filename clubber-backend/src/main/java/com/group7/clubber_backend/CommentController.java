package com.group7.clubber_backend;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam; // Assuming schema package
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import com.group7.clubber_backend.Managers.CommentManager;
import com.group7.clubber_backend.Managers.ReviewManager;
import com.group7.clubber_backend.Managers.UserManager;
import com.group7.clubber_backend.Processors.CredentialProcessor;
import com.group7.lib.types.Comment.Comment;
import com.group7.lib.types.Ids.CommentId;
import com.group7.lib.types.Ids.ReviewId;
import com.group7.lib.types.Ids.UserId;
import com.group7.lib.types.Review.Review;
import com.group7.lib.types.Schemas.Comments.DeleteResponse;
import com.group7.lib.types.Schemas.Comments.GetAllByReviewResponse;
import com.group7.lib.types.Schemas.Comments.GetResponse;
import com.group7.lib.types.Schemas.Comments.PostResponse;
import com.group7.lib.types.Schemas.Comments.PutResponse;
import com.group7.lib.types.User.User;

@RestController
@RequestMapping("/reviews/{reviewId}/comments") // Nested under reviews
public class CommentController {

    private final CommentManager commentManager = CommentManager.getInstance();
    private final UserManager userManager = UserManager.getInstance();
    private final ReviewManager reviewManager = ReviewManager.getInstance(); // To check if review exists
    private final CredentialProcessor credentialProcessor = CredentialProcessor.getInstance();

    // Create a new comment on a review
    @PostMapping
    public PostResponse createComment(@RequestHeader("Authorization") String token,
            @PathVariable String reviewId,
            @RequestParam("text") String text) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId authorUserId = credentialProcessor.verifyToken(token);
        if (authorUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }
        User author = userManager.get(authorUserId);
        if (author == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: User not found");
        }

        ReviewId reviewIdStr;
        try {
            reviewIdStr = new ReviewId(reviewId);
        } catch (IllegalArgumentException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid review ID format");
        }

        // Check if the review exists
        Review review = reviewManager.get(reviewIdStr);
        if (review == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Review not found, cannot post comment");
        }

        Comment newComment = new Comment(
                null, // ID will be generated by the manager
                authorUserId,
                reviewIdStr,
                text,
                LocalDateTime.now(),
                LocalDateTime.now()
        );

        CommentId commentId = (CommentId) commentManager.create(newComment);
        if (commentId == null) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to create comment");
        }
        return new PostResponse(commentId, "Comment created successfully"); // Assuming PostResponse schema
    }

    // Get a specific comment by its ID (though usually comments are fetched via review)
    @GetMapping("/{commentId}")
    public GetResponse getCommentById(@PathVariable String reviewId, @PathVariable String commentId) {
        // Validate reviewId path consistency if necessary, or just use commentId if globally unique
        CommentId commentIdStr = new CommentId(commentId);
        Comment comment = commentManager.get(commentIdStr);

        if (comment == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }
        // Optional: Check if comment.reviewId() matches reviewIdStr for consistency
        if (!comment.reviewId().toString().equals(reviewId)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Comment does not belong to this review");
        }

        return new GetResponse(comment); // Assuming GetResponse schema
    }

    // Get all comments for a specific review
    @GetMapping
    public GetAllByReviewResponse getCommentsByReview(@PathVariable String reviewId) {
        ReviewId reviewIdStr = new ReviewId(reviewId);
        // Check if the review exists
        if (reviewManager.get(reviewIdStr) == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Review not found");
        }
        // This requires a new search method in CommentManager, e.g., search("reviewId:" + reviewIdStr)
        // Or a dedicated method like findByReviewId(new ReviewId(reviewIdStr))
        List<Comment> comments = commentManager.search("reviewId:" + reviewId);
        return new GetAllByReviewResponse(comments); // Assuming this schema exists
    }

    // Update an existing comment
    @PutMapping("/{commentId}")
    public PutResponse updateComment(@RequestHeader("Authorization") String token,
            @PathVariable String reviewId,
            @PathVariable String commentId,
            @RequestParam("text") String text) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId currentUserId = credentialProcessor.verifyToken(token);
        if (currentUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }

        CommentId commentIdStr = new CommentId(commentId);
        Comment existingComment = commentManager.get(commentIdStr);

        if (existingComment == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }

        // Check if the comment belongs to the specified review
        if (!existingComment.reviewId().toString().equals(reviewId)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Comment does not belong to this review");
        }

        // Check if the current user is the author of the comment
        if (!existingComment.userId().equals(currentUserId)) {
            throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Forbidden: You are not the author of this comment");
        }

        Comment updatedComment = new Comment(
                existingComment.id(),
                existingComment.userId(),
                existingComment.reviewId(),
                text, // Only text can be updated for now
                existingComment.createdAt(),
                LocalDateTime.now() // Update the updatedAt timestamp
        );

        commentManager.update(updatedComment);
        return new PutResponse(updatedComment, "Comment updated successfully"); // Assuming PutResponse schema
    }

    // Delete a comment
    @DeleteMapping("/{commentId}")
    public DeleteResponse deleteComment(@RequestHeader("Authorization") String token,
            @PathVariable String reviewId,
            @PathVariable String commentId) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId currentUserId = credentialProcessor.verifyToken(token);
        if (currentUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }

        CommentId commentIdStr = new CommentId(commentId);
        Comment commentToDelete = commentManager.get(commentIdStr);

        if (commentToDelete == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }

        // Check if the comment belongs to the specified review
        if (!commentToDelete.reviewId().toString().equals(reviewId)) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Comment does not belong to this review");
        }

        // Authorization: Check if current user is the author. 
        // Add admin/review author deletion rights if necessary.
        if (!commentToDelete.userId().equals(currentUserId)) {
            throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Forbidden: You are not authorized to delete this comment");
        }

        commentManager.delete(commentIdStr);
        return new DeleteResponse("Comment deleted successfully"); // Assuming DeleteResponse schema
    }
}
