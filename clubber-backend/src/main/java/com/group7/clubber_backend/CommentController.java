package com.group7.clubber_backend;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam; // Assuming schema package
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import com.group7.clubber_backend.Managers.CommentManager;
import com.group7.clubber_backend.Managers.ReviewManager;
import com.group7.clubber_backend.Managers.UserManager;
import com.group7.clubber_backend.Processors.CredentialProcessor;
import com.group7.lib.types.Comment.Comment;
import com.group7.lib.types.Ids.CommentId;
import com.group7.lib.types.Ids.ReviewId;
import com.group7.lib.types.Ids.UserId;
import com.group7.lib.types.Review.Review;
import com.group7.lib.types.Schemas.Comments.GetResponse;
import com.group7.lib.types.Schemas.Comments.ListResponse;
import com.group7.lib.types.Schemas.Comments.PostResponse;
import com.group7.lib.types.User.User;

@RestController
@RequestMapping("/comments") // Nested under reviews
public class CommentController {

    private final CommentManager commentManager = CommentManager.getInstance();
    private final UserManager userManager = UserManager.getInstance();
    private final ReviewManager reviewManager = ReviewManager.getInstance(); // To check if review exists
    private final CredentialProcessor credentialProcessor = CredentialProcessor.getInstance();

    // Create a new comment on a review
    @PostMapping
    public PostResponse createComment(@RequestHeader("Authorization") String token,
            @RequestParam("reviewId") String reviewId,
            @RequestParam("text") String text) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId authorUserId = credentialProcessor.verifyToken(token);
        if (authorUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }
        User author = userManager.get(authorUserId);
        if (author == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: User not found");
        }

        ReviewId reviewIdStr;
        try {
            reviewIdStr = new ReviewId(reviewId);
        } catch (IllegalArgumentException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid review ID format");
        }

        // Check if the review exists
        Review review = reviewManager.get(reviewIdStr);
        if (review == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Review not found, cannot post comment");
        }

        Comment newComment = new Comment(
                null, // ID will be generated by the manager
                authorUserId,
                reviewIdStr,
                text,
                LocalDateTime.now(),
                LocalDateTime.now()
        );

        CommentId commentId = (CommentId) commentManager.create(newComment);
        if (commentId == null) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to create comment");
        }
        return new PostResponse(commentId);
    }

    // Get a specific comment by its ID
    @GetMapping("/{commentIdStr}")
    public GetResponse getCommentById(@PathVariable String commentIdStr) {
        CommentId commentId = new CommentId(commentIdStr);
        Comment comment = commentManager.get(commentId);

        if (comment == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }

        return new GetResponse(comment);
    }

    // Get all comments for a specific review
    @GetMapping("/reviews/{reviewIdStr}")
    public ListResponse getCommentsByReview(@PathVariable String reviewIdStr) {
        ReviewId reviewId = new ReviewId(reviewIdStr);
        if (reviewManager.get(reviewId) == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Review not found");
        }
        List<Comment> comments = commentManager.search("reviewId:" + reviewId);
        return ListResponse.fromComments(comments);
    }

    @GetMapping("/users/{userIdStr}")
    public ListResponse getCommentsByUser(@PathVariable String userIdStr) {
        UserId userId = new UserId(userIdStr);
        List<Comment> comments = commentManager.search("userId:" + userId);
        return ListResponse.fromComments(comments);
    }

    // Update an existing comment
    @PutMapping("/{commentIdStr}")
    public void updateComment(@RequestHeader("Authorization") String token,
            @PathVariable String commentIdStr,
            @RequestParam("text") String text) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId currentUserId = credentialProcessor.verifyToken(token);
        if (currentUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }

        CommentId commentId = new CommentId(commentIdStr);
        Comment existingComment = commentManager.get(commentId);

        if (existingComment == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }

        // Check if the current user is the author of the comment
        if (!existingComment.userId().equals(currentUserId)) {
            throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Forbidden: You are not the author of this comment");
        }

        Comment updatedComment = new Comment(
                existingComment.id(),
                existingComment.userId(),
                existingComment.reviewId(),
                text, // Only text can be updated for now
                existingComment.createdAt(),
                LocalDateTime.now() // Update the updatedAt timestamp
        );

        commentManager.update(updatedComment);
    }

    // Delete a comment
    @DeleteMapping("/{commentIdStr}")
    public void deleteComment(@RequestHeader("Authorization") String token,
            @PathVariable String commentIdStr) {
        if (token == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Token missing");
        }
        UserId currentUserId = credentialProcessor.verifyToken(token);
        if (currentUserId == null) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Unauthorized: Invalid or expired token");
        }

        CommentId commentId = new CommentId(commentIdStr);
        Comment commentToDelete = commentManager.get(commentId);

        if (commentToDelete == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment not found");
        }

        // Authorization: Check if current user is the author. 
        // Add admin/review author deletion rights if necessary.
        if (!commentToDelete.userId().equals(currentUserId)) {
            throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Forbidden: You are not authorized to delete this comment");
        }

        commentManager.delete(commentId);
    }
}
